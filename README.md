# Mailsender

Сервис сделан в 2021 году в рамках обучения на курсе Golang разработчик МТС.Тета (https://www.teta.mts.ru/golang).

## Преамбула

Архитектура сервиса, мягко говоря, нерациональна. Так сделано по следующим причинам:
- Роман на одной из лекций сказал, что нужно построить не рациональный сервис, а показать, как мы умеем выполнять разные упражнения;
- задание усложнялось постепенно, выполнялось, но запросы на кодревью не удовлетворялись, поэтому старый функционал не убирался; в первый раз кодревью был сделан 15.12.2021.

Следует отметить, что в начале курса я был совсем неопытен и, так как старый функционал не удалялся в сервисе есть куски кода, написанные в разное время на разных стадиях обучения. Очередь писалась в начале обучения и потом правилась по необходимости. Также сразу была сделано отправка писем по smtp. Потом сделана kafka. Затем сильно переделан модуль отправки по smtp, реализован пул воркеров. Потом реализован rate limit. Потом - выключение сервиса. Каждая новая функциональная возможность благоприятным образом изменяла часть архитектуры сервиса, но некоторые куски кода остались наивными.


## Что делает mailsender.

Сервис принимает из kafka сообщения, представляющие собой массив рассылок.
Образец:

[{"Subject":"прочесть и уничтожить","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому.","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Иваныч"}, {"Subject":"тема второго сообщения","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому. Но это другое сообщение","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Кузьмич"}, {"Subject":"третья рассылка","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому. Третье тело.","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Иваныч"}, {"Subject":"Четвёртое письмо","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому. Четвёртое.","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Иваныч"}, {"Subject":"пять","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому. Пять","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Иваныч"}, {"Subject":"Шесть","Body":"Учительница русского языка, когда первый раз прыгала с парашютом, была сильно потрясена,весьма удивлена и крайне обескуражена, но вслух почему-то кричала по-другому.Шесть.","Addresses":["suocq@mailto.plus", "tcuboa@mailto.plus"], "Token":"Иван Иваныч"}]

Образец такой толстый, чтобы наблюдать работу пула воркеров и rate limit.

Обработчик событий для kafka разбивает массив на отдельные рассылки и кладёт указатели на письма в канал, который слушает обработчик внутренней очереди.

Внутренняя очередь - это такой рудимент, который оставлен, так как см. преамбулу. Изначально очердь была в памяти, потом в mongo.

Обработчик событий очереди получает указатель на рассылку и кладёт его в базу (в боевой верссии база на mongo, в тестовой - в памяти).
Он же (обработчик событий очереди) пытается получить сообщения из базы. Так получилось, потому что в некоторый момент по заданию сообщения должны были поступать из bodyshop через mongo.

Обработчик событий очереди, получив сообщение для рассылки из базы, отправляет ссылку на сообщение в канал для mailer'а.

У mailer'а есть пул воркеров, отправляющих письма по SMTP с помощью сервиса google.
Ограничение сервиса - 99 сообщений в день. Отправка писем ограничена rate limit, параметры которого устанавливаются переменными окружения. Адресаты в BCC. Результат отправки фиксирует, устанавливая статус отправки сообщения, и отправлется в канал для обработчика очереди.

Если генератор случайных числе решил, что не надо отправлять письмо, возвращается ошибка  и статус письма изменяется на "error". Но я выключил этот функционал для тестов.
Письма со статусом "error" не пытаются отправить заново. 

Сообщение со статусом, установленным по итогу отправки по smtp, пересылается в канал для kafka обработчиком событий очереди.

Обработчик событий для kafka получает это сообщение из канала и отправляет в топик для profile.

Запрос postman'а рядышком лежит.

## Тестирование сервиса:

Для тестирования сервисы собран маленький сервис на порту 8000.

Нужно сделать POST на эндпойнт "/post", отправив массив рассылок.

Это сообщение подкладывается в kafka в топик, предназначенный для mailsender'а, как будто его отправил bodyshop.

1. Скопировать файл конфигурации config из корня репозитория в ~/.kube/
2. Установить namespace в конфиге:
kubectl config set-context --current --namespace=team15
3. Получить имя сервиса
kubectl get pods | grep mailsender | awk '{print $1}'
4. Прокинуть порт
kubectl port-forward  <имя сервиса> 8000:8000
5. Загрузить приложенную коллекцию (MailSenderTest.postman_collection.json) в postman: Collections->Import
6. Можно оставить существующие адреса для рассылки ("tcuboa@mailto.plus", "suocq@mailto.plus" и т.д.) или вписать свои. Поле Addresses должно быть массивом. При желании отредактировать тему и предмет письма и выполнить запрос. Сервис принимает массив писем.
7. С вероятность 1/2 письмо будет отправлено. Случайность - это условие задачи. Если случайность потребует не отправлять письмо, в логах будет запись "randomly func Letter.Send decided not to send".
8. Http сервис положит письмо в kafka (будет виден след в топике mts-to-mailsender), потом письме появится в mongo, потом изменится его статус, результат отразится в kafka в топике mts-to-profile. Письмо также должно прийти на почту, если не рандомайзер не отменит отправку, и если адресаты правильные и т.д.

P.S. использованные в образцах почтовые адреса обслуживаются сервисом https://tempmail.plus/ , позволяющим посмотреть интересующие почтовые ящики без паролей.

## shutdown

Реализован Graceful shutdown.
Для иниаицлизации нужно сделать post на endpoint /halt

В штатном режиме параллельно работают следующие потоки:
- limiter (обеспечивает rate limit на отправку писем)
- пул worker'ов mailer'а
- два потока разгребатора кафки (из очереди в кафку и из кафки в очередь)
- разгребатор очереди

Для корректного выключения выполняются следующие условия:
- дождаться отправки писем, которые уже отправляются (получили тикер от limiter'а)
- очередь, дождавшись выключения mailer'а. выполняет запрос в монгу, чтобы все письма со статусом "processing" вернуть в состояние "awaiting" (это те письма, которые были переданы на отправку, но не успели обработаться)
- mongo получает команду на выключение после завершения работы очереди


